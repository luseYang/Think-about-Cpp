# 一、多态基础

---

## 虚函数

在函数前面加上 virtual 就是声明虚函数，virtual 说明符指定**非静态成员函数**为虚函数并支持动态调用派发。  

它只能在非静态成员函数的首个声明（即当它在类定义中声明时）的 *声明说明符序列* 中出现。（声明说明符序列：在C语言中，声明说明符序列（declaration specifiers）是用来声明变量、函数或类型的一部分，它们定义了类型和属性。一个典型的声明说明符序列包括存储类说明符、类型说明符、类型限定符和函数说明符。）

虚函数调用在使用有限定名字查找（即函数名出现在作用域解析运算符 :: 的右侧）时被抑制。

> ### 虚函数的继承

虚函数的继承体现了接口继承

继承了接口等于继承了函数的壳,这个壳有返回值类型,函数名,参数列表,还包括了缺省参数

只需要重写/覆盖接口的实现(函数体)

---

## 虚类/虚基类

含有虚函数的类叫做虚类

是虚类且是基类的叫虚基类

---

## 重写/覆盖

> 条件：  
三同：函数名，参数，返回值都要相同

> 概念：  
重写/覆盖是指该函数是虚函数且函数的名字、类型、返回值完全一样的情况下,子类的函数体会替换掉继承下来的父类虚函数的函数体

体现接口继承

- 重写/覆盖只有虚函数才有,非虚函数的是隐藏/重定义.注意区别

- 重写/覆盖只对函数体有效,返回值类型,函数名,参数列表,和缺省参数都不能修改

- 只要子类写上满足三同的虚函数都会触发重写.无论是否修改函数体

上面说的函数重写的条件中，如果函数 Derived::f 覆盖 Base::f，那么它的返回类型必须要么相同，要么为协变（covariant）。当满足以下所有要求时，两个类型为协变：

- 两个类型都是到类的指针或引用（都是左值引用，或都是右值引用）。不允许多级指针。
- Base::f() 的返回类型中被引用/指向的类，必须是 Derived::f() 的返回类型中被引用/指向的类的无歧义且可访问的直接或间接基类。
- Derived::f() 的返回类型必须有相对于 Base::f() 的返回类型的相等或较少的 cv 限定。

Derived::f 的返回类型中的类必须要么是 Derived 自身，要么必须是在 Derived::f 声明点的某个完整类型。

进行虚函数调用时，最终覆盖函数的返回类型被隐式转换成所调用的被覆盖函数的返回类型：

```cpp
class Animal {};
class Dog : public Animal {};

class AnimalShelter {
public:
    virtual Animal* adopt() {
        return new Animal();
    }
};

class DogShelter : public AnimalShelter {
public:
    Dog* adopt() override { // 协变返回类型
        return new Dog();
    }
};

```

为什么要引入协变：  
协变的引入主要是为了提高代码的灵活性和可重用性。它允许子类在重写方法时返回更具体的类型，从而提供更多的功能和类型信息，而不破坏多态性和继承的规则。

协变解决的问题：  
类型安全：协变确保了类型系统的安全性，即在重写方法时，返回的类型依然是基类返回类型的子类型，保证了对象可以被正确识别和操作。

代码灵活性：协变使得子类方法可以返回更具体的类型，从而使得方法调用者可以利用更多的类型信息进行操作，而不需要进行类型转换。

提高代码可读性和可维护性：通过协变，代码变得更加直观和易于理解，因为方法返回类型直接反映了实际返回的对象类型。

总之,当虚函数返回值为基类类型的**指针或引用时**，编译器才会检查是否是协变类型.此时如果派生类虚函数返回值是基类或派生类的指针或引用,则判定为协变;否则不是协变

---

## 多态的条件

多态有两个条件，任何一个不满足都不能执行多态，分别是：
1. 虚函数的重写
2. 父类类型的指针或引用(接收父类对象或子类对象)的对象去调用虚函数

---

## 继承遗留问题解决

析构函数：  

先看继承关系中直接实例对象的代码：

```cpp
class Person {
public:
    ~Person() { std::cout << "~Person()" << "\n"; }
};

class Student :public Person {
public:
    ~Student() { std::cout << "~Student()" << "\n"; }
};

int main(){
    Person per; 
    Student stu;
    return 0;
}
```

打印结果是 ~Student() ,  ~Person() ,  ~Person() 。析构的结果和顺序没有问题。当对象被销毁时，析构函数的调用顺序是先调用子类的析构函数，然后再调用父类的析构函数。这个顺序确保子类特有的资源先被释放，然后父类的资源再被释放。

再看看指针切片样例：

```cpp
int main(){
    Person* ptr1 = new Person; 
    Person* ptr2 = new Student;

    delete ptr1;
    delete ptr2;
    return 0;
}
```

结果打印 ~Person(), ~Person() 。显然没有正确地析构。这说明切片样例中的对象执行析构后只会执行对应切片类型的析构函数。

本意：**根据指针(引用)指向的对象类型来选择对应的析构函数**

结果：**根据指针(引用)的类型的来选择对应的析构函数**

我们当然是想根据指针(引用)指向的对象类型来选择对应的析构函数，这正好就是多态的理念.

因此,为了解决切片中这样的析构函数问题,我们选择将其转化成多态来解决.

此时我们已经满足多态构造的2个条件的其中之一:基类的指针或引用， 剩下的我们需要满足派生类的析构函数构成对基类析构函数的重写。而重写的条件是：返回值类型，函数名，参数列表都相同。对于析构函数，目前还缺的就是函数名相同，因此,析构函数的名称统一处理为 destructor.

---

## 题目一
1.以下程序输出结果是什么（）

```cpp
class A  { 
public:
    virtual void func(int val = 1){ std::cout<<"A->"<< val <<std::endl;}
    virtual void test(){ func();} 
};

class B : public A { 
public:
    void func(int val=0){ std::cout<<"B->"<< val <<std::endl; } 
};

int main(int argc ,char* argv[]) {
    B*p = new B;
    p->test(); 
    return 0;
}
```

A: A->0 B: B->1 C: A->1 D: B->0 E: 编译出错 F: 以上都不正确
