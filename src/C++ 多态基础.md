# 一、多态基础

---

## 虚函数

在函数前面加上 virtual 就是声明虚函数，virtual 说明符指定**非静态成员函数**为虚函数并支持动态调用派发。  

它只能在非静态成员函数的首个声明（即当它在类定义中声明时）的 *声明说明符序列* 中出现。（声明说明符序列：在C语言中，声明说明符序列（declaration specifiers）是用来声明变量、函数或类型的一部分，它们定义了类型和属性。一个典型的声明说明符序列包括存储类说明符、类型说明符、类型限定符和函数说明符。）

虚函数调用在使用有限定名字查找（即函数名出现在作用域解析运算符 :: 的右侧）时被抑制。

> ### 虚函数的继承

虚函数的继承体现了接口继承

继承了接口等于继承了函数的壳,这个壳有返回值类型,函数名,参数列表,还包括了缺省参数

只需要重写/覆盖接口的实现(函数体)

---

## 虚类/虚基类

含有虚函数的类叫做虚类

是虚类且是基类的叫虚基类

---

## 重写/覆盖

> 条件：  
三同：函数名，参数，返回值都要相同

> 概念：  
重写/覆盖是指该函数是虚函数且函数的名字、类型、返回值完全一样的情况下,子类的函数体会替换掉继承下来的父类虚函数的函数体

体现接口继承

- 重写/覆盖只有虚函数才有,非虚函数的是隐藏/重定义.注意区别

- 重写/覆盖只对函数体有效,返回值类型,函数名,参数列表,和缺省参数都不能修改

- 只要子类写上满足三同的虚函数都会触发重写.无论是否修改函数体

上面说的函数重写的条件中，如果函数 Derived::f 覆盖 Base::f，那么它的返回类型必须要么相同，要么为协变（covariant）。当满足以下所有要求时，两个类型为协变：

- 两个类型都是到类的指针或引用（都是左值引用，或都是右值引用）。不允许多级指针。
- Base::f() 的返回类型中被引用/指向的类，必须是 Derived::f() 的返回类型中被引用/指向的类的无歧义且可访问的直接或间接基类。
- Derived::f() 的返回类型必须有相对于 Base::f() 的返回类型的相等或较少的 cv 限定。

---

## 多态的条件

多态有两个条件，任何一个不满足都不能执行多态，分别是：
1. 虚函数的重写
2. 父类类型的指针或引用(接收父类对象或子类对象)的对象去调用虚函数

Derived::f 的返回类型中的类必须要么是 Derived 自身，要么必须是在 Derived::f 声明点的某个完整类型。

进行虚函数调用时，最终覆盖函数的返回类型被隐式转换成所调用的被覆盖函数的返回类型：

```cpp
class B {};
 
struct Base
{
    virtual void vf1();
    virtual void vf2();
    virtual void vf3();
    virtual B* vf4();
    virtual B* vf5();
};
 
class D : private B
{
    friend struct Derived; // 在 Derived 中，B 是 D 的可访问基类
};
 
class A; // 前置声明的类是不完整类型
 
struct Derived : public Base
{
    void vf1();    // 虚函数，覆盖 Base::vf1()
    void vf2(int); // 非虚函数，隐藏 Base::vf2()
//  char vf3();    // 错误：覆盖 Base::vf3，但具有不同且非协变的返回类型
    D* vf4();      // 覆盖 Base::vf4() 并具有协变的返回类型
//  A* vf5();      // 错误：A 是不完整类型
};
 
int main()
{
    Derived d;
    Base& br = d;
    Derived& dr = d;
 
    br.vf1(); // 调用 Derived::vf1()
    br.vf2(); // 调用 Base::vf2()
//  dr.vf2(); // 错误：vf2(int) 隐藏 vf2()
 
    B* p = br.vf4(); // 调用 Derived::vf4() 并将结果转换为 B*
    D* q = dr.vf4(); // 调用 Derived::vf4() 但不将结果转换为 B*
}
```
