# 背景

内存的分配与回收都是由开发人员在编写代码时主动完成的，好处是内存管理的开销较小，程序拥有更高的执行效率；弊端是依赖于开发者的水平，随着代码规模的扩大，极容易遗漏释放内存的步骤，或者一些不规范的编程可能会使程序具有安全隐患。如果对内存管理不当，可能导致程序中存在内存缺陷，甚至在运行期间程序崩溃。在开发中，最容易发生两种情况：

- 申请了内存却没有释放，造成内存泄漏
- 使用了已经释放的内存，造成 segment fault

所以，为了在保证性能的前提下，又能使得开发者不需要关心内存的释放，进而使得开发者能够将更多的精力投入到业务上，自 C++11 开始，STL 正式引入了智能指针。


# 所有权

智能指针一个很关键的点就是*是否拥有对象的所有权*，当我们通过 `std::make_xxxx` 或者 `new` 一个对象，那么就拥有了这个对象的所有权。

所有权分为：独占所有权，共享所有权，弱共享所有权


# 独占所有权

顾名思义，独占该对象。独占的意思就是不共享，所有权可以转移，但是转移之后，所有权也是独占。`auto_ptr` 和 `unique_ptr` 就是一种独占所有权方式的智能指针。

假设有个 `Object` 对象，如果 `A` 拥有该对象的话，就需要保证其在不使用该对象的时候，将该对象释放；而此时如果 `B` 也想拥有 `Object` 对象，那么就必须先让 `A` 放弃该对象所有权，然后 `B` 独享该对象，那么该对象的使用和释放就只归 `B` 所有，跟 `A` 没有关系了。

独占所有权具有以下几个特点：

- 如果创建或者复制了某个对象，就拥有了该对象
- 如果没有创建对象，而是将对象保留使用，同样拥有该对象的所有权
- 如果你拥有了某个对象的所有权，在不需要某一个对象时，需要释放它们


# 共享所有权

共享所有权，与独占所有权正好相反，对某个对象的所有权可以共享。`shared_ptr` 就是一种共享所有权方式的智能指针。

假设此时 `A` 拥有对象 `Object`，在没有其它拥有该对对象的情况下，对象的释放由 `A` 来负责；如果此时B也想拥有该对象，那么对象的释放由最后一个拥有它的来负责。

举一个我们经常遇到的例子，`socket` 连接，多个发送端(sender)可以使用其发送和接收数据。

# 弱共享所有权

弱共享所有权，指的是可以使用该对象，但是没有所有权，由真正拥有其所有权的来负责释放。`weak_ptr` 就是一种弱共享所有权方式的智能指针。
