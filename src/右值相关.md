# C++ 居然可以给右值赋值？
```cpp
#include <iostream>

struct A {
    
};

A f(){
    return {};
}

int main() {
    A a;
    f() = a;
}
```
[这段代码没有报错](https://godbolt.org/z/TT44xz5rY)，这里的 f() 应该是一个纯右值表达式，因为它是[一个返回类型是非引用的函数调用](https://zh.cppreference.com/w/cpp/language/value_category#:~:text=%E8%BF%94%E5%9B%9E%E7%B1%BB%E5%9E%8B%E6%98%AF%E9%9D%9E%E5%BC%95%E7%94%A8%E7%9A%84%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E6%88%96%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E7%AC%A6%E8%A1%A8%E8%BE%BE%E5%BC%8F%EF%BC%8C)。

类实际上会隐式声明一个复制赋值运算符，如果把它 delete 掉，还能成功运行吗？
```cpp
A& operator=(cosnt A&) = delete;
```
就不能了，因为 **右值不能用作内建赋值运算符及内建复合赋值运算符的左操作数。** 例子中的 f() = a的 = 不是内建的函数

# 移动语义相关
```cpp
#include <iostream>

int test(int&&) {}

int main(){
    int &&a = 1;
    test(a);    // 报错
}
```
局部声明的右值引用是某些情况下可以视为左值；这里需要 ```test(std::move(a));```.

&emsp;
移动语义与所有权：
```cpp
#include <iostream>
#include <memory>

int main(){
    // 所有权
    std::unique_ptr<int> p;
    std::coutt << (bool)p << '\n';    // 0
    p = std::make_unique<int>(6);
    std::coutt << (bool)p << '\n';    // 1

    //auto p2{ p };    报错，因为unique_ptr独占，删除了一些东西。unique_ptr(const unique_ptr&] = delete; unique_ptr& operator=(const unique_ptr&) = delete;
    auto p2{ std::move(p) };
    std::coutt << (bool)p << '\n';    // 0
    std::shared_ptr<int>p3{ new int{} };
    std::cout << p3.use_count() << \n';    // 1
    auto p4{ p3 };
    std::cout << p3.use_count() << n';    // 2
    auto p4 { std::move(p3) }:
    std ::cout << p3.use_count() << '\n';    // 0;
}
```
至此，你就可以理解移动语义了
